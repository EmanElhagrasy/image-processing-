
# 3-Image restoration, Noise, Segmentation and Contours
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2-Noise:
How can an image have noise? Well images are signals and real-world signals usually contain departures from the ideal signal, which is the perfect image, as we observe with our eyes in real life. Such departures are referred to as noise.More specifically, noise is the result of errors in the image acquisition process that result in pixel values that do not reflect the true intensities of the real scene.

  --------------------------------
-Apply noise in scikit-image:
  >>from skimage.util import random_noise
  >>noisy_image = random_noise(image)
  -------------------------------
  By using the random_noise function, we obtain the original image with a lot of added noise, that is distributed randomly. This type of noise is known as "salt and pepper" because that's in fact what it looks like.
  
-Reducing noise:
Most of the times we will want to remove or reduce the noise of images instead of adding it in.For that, we can use several algorithms in scikit-image.
"The higher the resolution of the image, the longer it may take to eliminate the noise"

Some types of denoising algorithms are: 
 1- The total variation filter(TV): This filter tries to minimize the total variation of the image. It tends to produce “cartoon-like” images, that is, piecewise-constant images
 2- Bilateral filtering: smooths images while preserving edges. It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.
 3- The wavelet denoising filter 
 4- Non-local means denoising.
 ----------------------------------------
Apply total variation filter(TV) in scikit-image:
>>from skimage.restoration import denoise_tv_chambolle
>>denoised_image = denoise_tv_chambolle(noisy_image, weight =.1 , multichannel = True)
# we can optionally set the denoising weight. The greater the weight, the more denoising but it could also make the image smoother.
------------------------------------------
Apply Bilateral filter denoising  in scikit-image:
>>from skimage.restoration import denoise_bilateral
>>denoised_image = denoise_bilateral(noisy_image, multichannel = True)
#The resulting image is less smooth than the one from the total variation filter. And preserves the edges a lot more.
------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3-Superpixels & segmentation:

 Segmentation: The goal is to partition images into regions, or segments, to simplify and/or change the representation into something more meaningful and easier to analyze.
                For example, before a tumor is analyzed in a computed tomography, it has to be detected and somehow isolated from the rest of the image. Or before recognizing a face, it has to also be picked out from its background.
                Previously we learned about Thresholding, which is the simplest method of segmentation. Separating foreground from background.

Image representation: Consider how we represent images. They are represented as a grid of pixels.
                      The issue is that they're not a completely natural representation of an image. 
                      If I were to take a single pixel from the image on the left and then showed it to you on the right, 
                      would you be able to tell that the pixel came from a puppy and that this single pixel holds a logical meaning? 
                      A single pixel, standing alone by itself, is not a natural representation.
                      So, we can explore more logical meanings in an image that's formed by bigger regions or grouped pixels. These are known as superpixels.

superpixel: is a group of connected pixels with similar colors or gray levels. These carry more meaning than their simple pixel grid counterparts.
            Superpixel segmentation is dividing an image into superpixels. It has been applied to many computer vision tasks, like visual tracking and image classification.
            Some advantages for using them are that You can compute features on more meaningful regions. And that you can reduce an image from thousands of pixels down
            to some regions for subsequent algorithms, so you have computational efficiency.

Segmentation:
Two types of segmentation are:
         1-Supervised, where some prior knowledge is used to guide the algorithm. Like the kind of thresholding in which we specify the threshold value ourselves.
         2-unsupervised where no prior knowledge is required. These algorithms try to subdivide images into meaningful regions automatically. The user may still be able to tweak certain settings to obtain the desired output.
           Like the otsu thresholding we used in first chapter.

Unsupervised segmentation technique: based on superpixels, called Simple Linear Iterative Clustering or SLIC. 
                                     It segments the image using a machine learning algorithm called K-Means clustering.
                                     It takes in all the pixel values of the image and tries to separate them into a predefined number of sub-regions.
--------------------------------------------------
Apply unsupervised segmentation (slic)
>>from skimage.segmentation import slic
>>from skimage.color import label2rgb
#obtain segments
>>segments =slic(image)
#put segments on top of original image to compare
>>segmented_image = label2rgb(segments, image , kind = 'avg')

#Here we use this function, with default parameters and obtain the segments.
 We'll use the label2rgb method from the color module to return an image where the segments obtained from the slic method will be highlighted,
 either with random colors or with the average color of the superpixel segment. In this example we'll use the average color. So we pass the segments or labels, 
 the image, and set the kind parameter to average avg.
 
 #If we want more segments, let's say 300, we can specify this with an optional parameter, n_segments. Its default value is 100 segments.
 >>segments =slic(image, n_segments = 300)
 ---------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4-Finding contours:
 
 Contour: is a closed shape of points or line segments, representing the boundaries of these objects. Once we find the contours,
 we can do things like identifying the total points in domino tokens,  we can measure size, classify shapes or determining the number of objects in an image.
 
 Binary images: The input to a contour-finding function should be a binary image, which we can produce by first applying thresholding.
                In such binary image, the objects we wish to detect should be white, while the background remains black.

Find contours using scikit-image:First, the image needs to go through some pre-processing steps. We need to turn the image to grayscale to later apply thresholding.
                                 We can do so by using the rgb2gray function from the color module.
                                 To use the find_contours function, we need the image we want to obtain contours from, to be binary. Meaning,
                                 black and white. Here we apply thresholding to do that, so we get a thresholded image.
-----------------------------------------------------
#Find contours
>>from skimage.color import rgb2gray
>>from skimage import filters
>>from skimage import measure
>>image_dice = color.rgb2gray(image_dice)
>>thresh = filters.threshold_otsu(image_dice)
>>binary = image_dice > thresh 
>>contours = measure.find_contours(binary, .8)

#This function finds the contour lines or joins points(pixels) of equal elevation or brightness in a 2D array above a given level value.
  We import the module "measure" from skimage. And from measure we call the function find_contours.
  The function returns a list with all contours of the image. With the coordinates along the contour.
  Passing the thresholded image as the first parameter and a constant level value of zero point eight. 
  The function returns a list with all contours of the image. With the coordinates along the contour.
------------------------------------------------------
Constant level value: The level value varies between 0 and 1, the closer to 1 the more sensitive the method is to detecting contours, 
                      so more complex contours will be detected. We have to find the value that best detects the contours we care for.

A contour's shape:After executing these steps we obtain a list of contours. Each contour is an ndarray of shape (n, 2),
                  consisting of n row and column coordinates along the contour. In this way, a contour is like an outline formed by multiple points joined together. 
                  The bigger the contour, the more points joined together and the wider the perimeter formed.
                  
------------------------------------------------------
Count the dots in a dice's image:
 # Create list with the shape of each contour
shape_contours = [cnt.shape[0] for cnt in contours]

# Set 50 as the maximum size of the dots shape
max_dots_shape = 50

# Count dots in contours excluding bigger than dots size
dots_contours = [cnt for cnt in contours if np.shape(cnt)[0] <max_dots_shape]

# Shows all contours found 
show_image_contour(binary, contours)

# Print the dice's number
print("Dice's dots number: {}. ".format(len(dots_contours)))
--------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

